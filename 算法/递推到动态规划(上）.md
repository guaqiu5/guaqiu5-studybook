# lc 70 爬楼梯

```c++
class Solution {
public:
    int climbStairs(int n) {
        vector<int> f(n+1);
        f[0]=1;
        f[1]=1;
        for(int i=2;i<=n;i++)
        {
            f[i]=f[i-1]+f[i-2];
        }
      	return f[n];
    }
};
```

# 数学归纳法

- step1:验证k0正确
- step2:证明如果ki成立，那么ki+1也成立
- 联合step1，2 证明k0->kn成立

# 如何求解递推



- 确定递推状态(最重要)

  函数，确定变量和因变量

- 确定递推公式
- 确定边界
- 程序实现
- f(n)=af(n-1)+bf(n-2)可用矩阵加速 复杂度到logn

# 动态规划

动态规划是递推的子问题，是求解最优化问题。

什么是最优化问题 lc 746

# lc 746 使用最小花费爬楼梯

dp(n)=min(dp(n-1),dp(n-1))+cost(n)

```c++
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int n=cost.size();
        vector<int> dp(n+1);
        cost.push_back(0);
        dp[0]=cost[0];
        dp[1]=cost[1];
        for(int i=2;i<n+1;i++)
        dp[i]=min(dp[i-1],dp[i-2])+cost[i];
        return dp[n];
    }
};
```

# lc 256 粉刷房子

没开会员 暂且不刷。

dp[n,i]=min{dp(n-1)两种}+cost[n,i]

滚动数组技巧

# lc 120  三角形最小路径和

```c++
class Solution {
public:
    int minimumTotal(vector<vector<int>>& t) {
    int n=t.size();
    if(n==1)
    return t[0][0];
    for(int i=n-2;i>=0;--i)
    for(int j=t[i].size()-1;j>=0;--j)
    t[i][j]+=min(t[i+1][j],t[i+1][j+1]);

    return t[0][0];
    }
};
```

